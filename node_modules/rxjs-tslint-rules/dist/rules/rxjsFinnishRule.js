"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Lint = require("tslint");
var tsutils = require("tsutils");
var util_1 = require("../support/util");
var defaultNamesRegExp = /^(canActivate|canActivateChild|canDeactivate|canLoad|intercept|resolve|validate)$/;
var defaultTypesRegExp = /^EventEmitter$/;
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));
    };
    Rule.metadata = {
        description: "Enforces the use of Finnish notation.",
        options: {
            properties: {
                functions: { type: "boolean" },
                methods: { type: "boolean" },
                names: { type: "object" },
                parameters: { type: "boolean" },
                properties: { type: "boolean" },
                types: { type: "object" },
                variables: { type: "boolean" }
            },
            type: "object"
        },
        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n            An optional object with optional `functions`, `methods`, `parameters`,\n            `properties` and `variables` properties.\n            The properies are booleans and determine whether or not Finnish notation is enforced.\n            All properties default to `true`.\n            The object also has optional `names` and `types` properties which are themselves\n            objects containing keys that are regular expressions and values that are booleans -\n            indicating whether Finnish notation is required for particular names or types."], ["\n            An optional object with optional \\`functions\\`, \\`methods\\`, \\`parameters\\`,\n            \\`properties\\` and \\`variables\\` properties.\n            The properies are booleans and determine whether or not Finnish notation is enforced.\n            All properties default to \\`true\\`.\n            The object also has optional \\`names\\` and \\`types\\` properties which are themselves\n            objects containing keys that are regular expressions and values that are booleans -\n            indicating whether Finnish notation is required for particular names or types."]))),
        requiresTypeInfo: true,
        ruleName: "rxjs-finnish",
        type: "style",
        typescriptOnly: true
    };
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var Walker = (function (_super) {
    tslib_1.__extends(Walker, _super);
    function Walker(sourceFile, rawOptions, program) {
        var _this = _super.call(this, sourceFile, rawOptions, program) || this;
        _this.names = [];
        _this.types = [];
        _this.validate = {
            functions: true,
            methods: true,
            parameters: true,
            properties: true,
            variables: true
        };
        var options = _this.getOptions()[0];
        if (options) {
            if (options.names) {
                Object.entries(options.names).forEach(function (_a) {
                    var key = _a[0], validate = _a[1];
                    _this.names.push({ regExp: new RegExp(key), validate: validate });
                });
            }
            else {
                _this.names.push({ regExp: defaultNamesRegExp, validate: false });
            }
            if (options.types) {
                Object.entries(options.types).forEach(function (_a) {
                    var key = _a[0], validate = _a[1];
                    _this.types.push({ regExp: new RegExp(key), validate: validate });
                });
            }
            else {
                _this.types.push({ regExp: defaultTypesRegExp, validate: false });
            }
            _this.validate = tslib_1.__assign({}, _this.validate, options);
        }
        else {
            _this.names.push({ regExp: defaultNamesRegExp, validate: false });
            _this.types.push({ regExp: defaultTypesRegExp, validate: false });
        }
        return _this;
    }
    Walker.prototype.visitFunctionDeclaration = function (node) {
        if (this.validate.functions) {
            this.validateNode(node, node.type);
        }
        _super.prototype.visitFunctionDeclaration.call(this, node);
    };
    Walker.prototype.visitFunctionExpression = function (node) {
        if (this.validate.functions) {
            this.validateNode(node, node.type);
        }
        _super.prototype.visitFunctionExpression.call(this, node);
    };
    Walker.prototype.visitGetAccessor = function (node) {
        if (this.validate.properties) {
            this.validateNode(node);
        }
        _super.prototype.visitGetAccessor.call(this, node);
    };
    Walker.prototype.visitMethodDeclaration = function (node) {
        if (this.validate.methods) {
            this.validateNode(node, node.type);
        }
        _super.prototype.visitMethodDeclaration.call(this, node);
    };
    Walker.prototype.visitMethodSignature = function (node) {
        if (this.validate.methods) {
            this.validateNode(node, node.type);
        }
        _super.prototype.visitMethodSignature.call(this, node);
    };
    Walker.prototype.visitObjectLiteralExpression = function (node) {
        var _this = this;
        if (this.validate.properties) {
            node.properties.forEach(function (property) {
                if (property.name && !tsutils.isComputedPropertyName(property.name)) {
                    _this.validateNode(property);
                }
            });
        }
        _super.prototype.visitObjectLiteralExpression.call(this, node);
    };
    Walker.prototype.visitParameterDeclaration = function (node) {
        if (this.validate.parameters) {
            this.validateNode(node);
        }
        _super.prototype.visitParameterDeclaration.call(this, node);
    };
    Walker.prototype.visitPropertyDeclaration = function (node) {
        if (this.validate.properties) {
            this.validateNode(node);
        }
        _super.prototype.visitPropertyDeclaration.call(this, node);
    };
    Walker.prototype.visitPropertySignature = function (node) {
        if (this.validate.properties) {
            this.validateNode(node);
        }
        _super.prototype.visitPropertySignature.call(this, node);
    };
    Walker.prototype.visitSetAccessor = function (node) {
        if (this.validate.properties) {
            this.validateNode(node);
        }
        _super.prototype.visitSetAccessor.call(this, node);
    };
    Walker.prototype.visitVariableDeclarationList = function (node) {
        var _this = this;
        if (this.validate.variables) {
            tsutils.forEachDeclaredVariable(node, function (variable) {
                _this.validateNode(variable);
            });
        }
        _super.prototype.visitVariableDeclarationList.call(this, node);
    };
    Walker.prototype.validateNode = function (node, typeNode) {
        var name = node.name;
        if (name) {
            var text = name.getText();
            var type = this.getTypeChecker().getTypeAtLocation(typeNode || node);
            if (!/\$$/.test(text) && util_1.couldBeType(type, "Observable")) {
                for (var i = 0; i < this.names.length; ++i) {
                    var _a = this.names[i], regExp = _a.regExp, validate = _a.validate;
                    if (regExp.test(text) && !validate) {
                        return;
                    }
                }
                for (var i = 0; i < this.types.length; ++i) {
                    var _b = this.types[i], regExp = _b.regExp, validate = _b.validate;
                    if (util_1.couldBeType(type, regExp) && !validate) {
                        return;
                    }
                }
                this.addFailureAtNode(name, "Finnish notation required for " + text);
            }
        }
    };
    return Walker;
}(Lint.ProgramAwareRuleWalker));
var templateObject_1;
